import "./chunk-VGC2NAOA.js";
import {
  cloneVNode,
  computed,
  defineComponent,
  h,
  inject,
  nextTick,
  onMounted,
  onUnmounted,
  provide,
  reactive,
  ref,
  watch,
  watchEffect,
  withModifiers
} from "./chunk-AWD2DKKE.js";
import "./chunk-J43GMYXM.js";

// node_modules/vue3-carousel/dist/carousel.es.js
var defaultConfigs = {
  itemsToShow: 1,
  itemsToScroll: 1,
  modelValue: 0,
  transition: 300,
  autoplay: 0,
  snapAlign: "center",
  wrapAround: false,
  pauseAutoplayOnHover: false,
  mouseDrag: true,
  touchDrag: true,
  dir: "ltr",
  breakpoints: void 0
};
var carouselProps = {
  itemsToShow: {
    default: defaultConfigs.itemsToShow,
    type: Number
  },
  itemsToScroll: {
    default: defaultConfigs.itemsToScroll,
    type: Number
  },
  wrapAround: {
    default: defaultConfigs.wrapAround,
    type: Boolean
  },
  snapAlign: {
    default: defaultConfigs.snapAlign,
    validator(value) {
      return ["start", "end", "center", "center-even", "center-odd"].includes(value);
    }
  },
  transition: {
    default: defaultConfigs.transition,
    type: Number
  },
  breakpoints: {
    default: defaultConfigs.breakpoints,
    type: Object
  },
  autoplay: {
    default: defaultConfigs.autoplay,
    type: Number
  },
  pauseAutoplayOnHover: {
    default: defaultConfigs.pauseAutoplayOnHover,
    type: Boolean
  },
  modelValue: {
    default: void 0,
    type: Number
  },
  mouseDrag: {
    default: defaultConfigs.mouseDrag,
    type: Boolean
  },
  touchDrag: {
    default: defaultConfigs.touchDrag,
    type: Boolean
  },
  dir: {
    default: defaultConfigs.dir,
    validator(value) {
      return ["rtl", "ltr"].includes(value);
    }
  },
  settings: {
    default() {
      return {};
    },
    type: Object
  }
};
function debounce(fn, delay) {
  let timerId;
  return function(...args) {
    if (timerId) {
      clearTimeout(timerId);
    }
    timerId = setTimeout(() => {
      fn(...args);
      timerId = null;
    }, delay);
  };
}
function throttle(fn, limit) {
  let inThrottle;
  return function(...args) {
    const self = this;
    if (!inThrottle) {
      fn.apply(self, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}
function getSlidesVNodes(vNode) {
  var _a, _b, _c;
  if (!vNode)
    return [];
  if (((_b = (_a = vNode[0]) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.name) === "CarouselSlide")
    return vNode;
  return ((_c = vNode[0]) === null || _c === void 0 ? void 0 : _c.children) || [];
}
function getMaxSlideIndex(config, slidesCount) {
  if (config.wrapAround) {
    return slidesCount - 1;
  }
  switch (config.snapAlign) {
    case "start":
      return slidesCount - config.itemsToShow;
    case "end":
      return slidesCount - 1;
    case "center":
    case "center-odd":
      return slidesCount - Math.ceil((config.itemsToShow - 0.5) / 2);
    case "center-even":
      return slidesCount - Math.ceil(config.itemsToShow / 2);
    default:
      return 0;
  }
}
function getMinSlideIndex(config) {
  if (config.wrapAround) {
    return 0;
  }
  switch (config.snapAlign) {
    case "start":
      return 0;
    case "end":
      return config.itemsToShow - 1;
    case "center":
    case "center-odd":
      return Math.floor((config.itemsToShow - 1) / 2);
    case "center-even":
      return Math.floor((config.itemsToShow - 2) / 2);
    default:
      return 0;
  }
}
function getCurrentSlideIndex(config, val, max, min) {
  if (config.wrapAround) {
    return val;
  }
  return Math.min(Math.max(val, min), max);
}
function getSlidesToScroll({ currentSlide, snapAlign, itemsToShow, wrapAround, slidesCount }) {
  let output = currentSlide;
  if (snapAlign === "center" || snapAlign === "center-odd") {
    output -= (itemsToShow - 1) / 2;
  } else if (snapAlign === "center-even") {
    output -= (itemsToShow - 2) / 2;
  } else if (snapAlign === "end") {
    output -= itemsToShow - 1;
  }
  if (!wrapAround) {
    const max = slidesCount - itemsToShow;
    const min = 0;
    output = Math.max(Math.min(output, max), min);
  }
  return output;
}
function mapNumberToRange(current, max, min = 0) {
  if (current > max) {
    return mapNumberToRange(current - (max + 1), max, min);
  }
  if (current < min) {
    return mapNumberToRange(current + (max + 1), max, min);
  }
  return current;
}
var ARIAComponent = defineComponent({
  name: "ARIA",
  setup() {
    const currentSlide = inject("currentSlide", ref(0));
    const slidesCount = inject("slidesCount", ref(0));
    return () => h("div", {
      class: ["carousel__liveregion", "carousel__sr-only"],
      "aria-live": "polite",
      "aria-atomic": "true"
    }, `Item ${currentSlide.value + 1} of ${slidesCount.value}`);
  }
});
var Carousel = defineComponent({
  name: "Carousel",
  props: carouselProps,
  setup(props, { slots, emit, expose }) {
    var _a;
    const root = ref(null);
    const slides = ref([]);
    const slideWidth = ref(0);
    const slidesCount = ref(1);
    let breakpoints = ref({});
    let __defaultConfig = Object.assign({}, defaultConfigs);
    const config = reactive(Object.assign({}, __defaultConfig));
    const currentSlideIndex = ref((_a = config.modelValue) !== null && _a !== void 0 ? _a : 0);
    const prevSlideIndex = ref(0);
    const middleSlideIndex = ref(0);
    const maxSlideIndex = ref(0);
    const minSlideIndex = ref(0);
    let autoplayTimer;
    let transitionTimer;
    provide("config", config);
    provide("slidesCount", slidesCount);
    provide("currentSlide", currentSlideIndex);
    provide("maxSlide", maxSlideIndex);
    provide("minSlide", minSlideIndex);
    provide("slideWidth", slideWidth);
    function initDefaultConfigs() {
      const mergedConfigs = Object.assign(Object.assign({}, props), props.settings);
      breakpoints = ref(Object.assign({}, mergedConfigs.breakpoints));
      __defaultConfig = Object.assign(Object.assign({}, mergedConfigs), { settings: void 0, breakpoints: void 0 });
      bindConfigs(__defaultConfig);
    }
    function updateBreakpointsConfigs() {
      const breakpointsArray = Object.keys(breakpoints.value).map((key) => Number(key)).sort((a, b) => +b - +a);
      let newConfig = Object.assign({}, __defaultConfig);
      breakpointsArray.some((breakpoint) => {
        const isMatched = window.matchMedia(`(min-width: ${breakpoint}px)`).matches;
        if (isMatched) {
          newConfig = Object.assign(Object.assign({}, newConfig), breakpoints.value[breakpoint]);
          return true;
        }
        return false;
      });
      bindConfigs(newConfig);
    }
    function bindConfigs(newConfig) {
      Object.entries(newConfig).forEach(([key, val]) => config[key] = val);
    }
    const handleWindowResize = debounce(() => {
      if (breakpoints.value) {
        updateBreakpointsConfigs();
        updateSlidesData();
      }
      updateSlideWidth();
    }, 16);
    function updateSlideWidth() {
      if (!root.value)
        return;
      const rect = root.value.getBoundingClientRect();
      slideWidth.value = rect.width / config.itemsToShow;
    }
    function updateSlidesData() {
      slidesCount.value = Math.max(slides.value.length, 1);
      if (slidesCount.value <= 0)
        return;
      middleSlideIndex.value = Math.ceil((slidesCount.value - 1) / 2);
      maxSlideIndex.value = getMaxSlideIndex(config, slidesCount.value);
      minSlideIndex.value = getMinSlideIndex(config);
      currentSlideIndex.value = getCurrentSlideIndex(config, currentSlideIndex.value, maxSlideIndex.value, minSlideIndex.value);
    }
    onMounted(() => {
      if (breakpoints.value) {
        updateBreakpointsConfigs();
        updateSlidesData();
      }
      nextTick(() => setTimeout(updateSlideWidth, 16));
      initAutoplay();
      window.addEventListener("resize", handleWindowResize, { passive: true });
    });
    onUnmounted(() => {
      if (transitionTimer) {
        clearTimeout(transitionTimer);
      }
      if (autoplayTimer) {
        clearInterval(autoplayTimer);
      }
    });
    let isTouch = false;
    const startPosition = { x: 0, y: 0 };
    const endPosition = { x: 0, y: 0 };
    const dragged = reactive({ x: 0, y: 0 });
    const isHover = ref(false);
    const handleMouseEnter = () => {
      isHover.value = true;
    };
    const handleMouseLeave = () => {
      isHover.value = false;
    };
    function handleDragStart(event) {
      isTouch = event.type === "touchstart";
      if (!isTouch && event.button !== 0 || isSliding.value) {
        return;
      }
      if (!isTouch) {
        event.preventDefault();
      }
      startPosition.x = isTouch ? event.touches[0].clientX : event.clientX;
      startPosition.y = isTouch ? event.touches[0].clientY : event.clientY;
      document.addEventListener(isTouch ? "touchmove" : "mousemove", handleDragging, true);
      document.addEventListener(isTouch ? "touchend" : "mouseup", handleDragEnd, true);
    }
    const handleDragging = throttle((event) => {
      endPosition.x = isTouch ? event.touches[0].clientX : event.clientX;
      endPosition.y = isTouch ? event.touches[0].clientY : event.clientY;
      const deltaX = endPosition.x - startPosition.x;
      const deltaY = endPosition.y - startPosition.y;
      dragged.y = deltaY;
      dragged.x = deltaX;
    }, 16);
    function handleDragEnd() {
      const direction = config.dir === "rtl" ? -1 : 1;
      const tolerance = Math.sign(dragged.x) * 0.4;
      const draggedSlides = Math.round(dragged.x / slideWidth.value + tolerance) * direction;
      if (draggedSlides && !isTouch) {
        const captureClick = (e) => {
          e.stopPropagation();
          window.removeEventListener("click", captureClick, true);
        };
        window.addEventListener("click", captureClick, true);
      }
      slideTo(currentSlideIndex.value - draggedSlides);
      dragged.x = 0;
      dragged.y = 0;
      document.removeEventListener(isTouch ? "touchmove" : "mousemove", handleDragging, true);
      document.removeEventListener(isTouch ? "touchend" : "mouseup", handleDragEnd, true);
    }
    function initAutoplay() {
      if (!config.autoplay || config.autoplay <= 0) {
        return;
      }
      autoplayTimer = setInterval(() => {
        if (config.pauseAutoplayOnHover && isHover.value) {
          return;
        }
        next();
      }, config.autoplay);
    }
    function resetAutoplay() {
      if (!config.autoplay || config.autoplay <= 0) {
        return;
      }
      if (autoplayTimer) {
        clearInterval(autoplayTimer);
        autoplayTimer = null;
      }
      initAutoplay();
    }
    const isSliding = ref(false);
    function slideTo(slideIndex) {
      if (currentSlideIndex.value === slideIndex || isSliding.value) {
        return;
      }
      isSliding.value = true;
      resetAutoplay();
      const currentVal = getCurrentSlideIndex(config, slideIndex, maxSlideIndex.value, minSlideIndex.value);
      prevSlideIndex.value = currentSlideIndex.value;
      currentSlideIndex.value = currentVal;
      transitionTimer = setTimeout(() => {
        const mappedNumber = mapNumberToRange(currentVal, maxSlideIndex.value);
        if (config.wrapAround) {
          currentSlideIndex.value = mappedNumber;
        }
        emit("update:modelValue", mappedNumber);
        isSliding.value = false;
      }, config.transition);
    }
    function next() {
      slideTo(currentSlideIndex.value + config.itemsToScroll);
    }
    function prev() {
      slideTo(currentSlideIndex.value - config.itemsToScroll);
    }
    const nav = { slideTo, next, prev };
    provide("nav", nav);
    provide("isSliding", isSliding);
    const slidesToScroll = computed(() => getSlidesToScroll({
      itemsToShow: config.itemsToShow,
      snapAlign: config.snapAlign,
      wrapAround: Boolean(config.wrapAround),
      currentSlide: currentSlideIndex.value,
      slidesCount: slidesCount.value
    }));
    provide("slidesToScroll", slidesToScroll);
    const trackStyle = computed(() => {
      const direction = config.dir === "rtl" ? -1 : 1;
      const xScroll = slidesToScroll.value * slideWidth.value * direction;
      return {
        transform: `translateX(${dragged.x - xScroll}px)`,
        transition: `${isSliding.value ? config.transition : 0}ms`,
        margin: config.wrapAround ? `0 -${slidesCount.value * slideWidth.value}px` : "",
        width: `100%`
      };
    });
    function initCarousel() {
      initDefaultConfigs();
    }
    function restartCarousel() {
      initDefaultConfigs();
      updateBreakpointsConfigs();
      updateSlidesData();
      updateSlideWidth();
      resetAutoplay();
    }
    function updateCarousel() {
      updateSlidesData();
    }
    Object.keys(carouselProps).forEach((prop) => {
      if (["modelValue"].includes(prop))
        return;
      watch(() => props[prop], restartCarousel);
    });
    watch(() => props["modelValue"], (val) => {
      if (val !== currentSlideIndex.value) {
        slideTo(Number(val));
      }
    });
    initCarousel();
    watchEffect(() => {
      if (slidesCount.value !== slides.value.length) {
        updateCarousel();
      }
    });
    const data = {
      config,
      slidesCount,
      slideWidth,
      currentSlide: currentSlideIndex,
      maxSlide: maxSlideIndex,
      minSlide: minSlideIndex,
      middleSlide: middleSlideIndex
    };
    expose({
      updateBreakpointsConfigs,
      updateSlidesData,
      updateSlideWidth,
      initCarousel,
      restartCarousel,
      updateCarousel,
      slideTo,
      next,
      prev,
      nav,
      data
    });
    const slotSlides = slots.default || slots.slides;
    const slotAddons = slots.addons;
    const slotsProps = reactive(data);
    return () => {
      const slidesElements = getSlidesVNodes(slotSlides === null || slotSlides === void 0 ? void 0 : slotSlides(slotsProps));
      const addonsElements = (slotAddons === null || slotAddons === void 0 ? void 0 : slotAddons(slotsProps)) || [];
      slidesElements.forEach((el, index) => el.props.index = index);
      let output = slidesElements;
      if (config.wrapAround) {
        const slidesBefore = slidesElements.map((el, index) => cloneVNode(el, { index: -slidesElements.length + index, isClone: true }));
        const slidesAfter = slidesElements.map((el, index) => cloneVNode(el, { index: slidesElements.length + index, isClone: true }));
        output = [...slidesBefore, ...slidesElements, ...slidesAfter];
      }
      slides.value = slidesElements;
      const trackEl = h("ol", {
        class: "carousel__track",
        style: trackStyle.value,
        onMousedown: config.mouseDrag ? withModifiers(handleDragStart, ["capture"]) : null,
        onTouchstart: config.touchDrag ? withModifiers(handleDragStart, ["capture"]) : null
      }, output);
      const viewPortEl = h("div", { class: "carousel__viewport" }, trackEl);
      return h("section", {
        ref: root,
        class: {
          carousel: true,
          "carousel--rtl": config.dir === "rtl"
        },
        dir: config.dir,
        "aria-label": "Gallery",
        tabindex: "0",
        onMouseenter: handleMouseEnter,
        onMouseleave: handleMouseLeave
      }, [viewPortEl, addonsElements, h(ARIAComponent)]);
    };
  }
});
var icons = {
  arrowUp: "M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z",
  arrowDown: "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z",
  arrowRight: "M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z",
  arrowLeft: "M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"
};
var Icon = (props) => {
  const iconName = props.name;
  if (!iconName || typeof iconName !== "string") {
    return;
  }
  const path = icons[iconName];
  const pathEl = h("path", { d: path });
  const iconTitle = props.title || iconName;
  const titleEl = h("title", iconTitle);
  return h("svg", {
    class: "carousel__icon",
    viewBox: "0 0 24 24",
    role: "img",
    ariaLabel: iconTitle
  }, [titleEl, pathEl]);
};
Icon.props = { name: String, title: String };
var Navigation = (props, { slots, attrs }) => {
  const { next: slotNext, prev: slotPrev } = slots || {};
  const config = inject("config", reactive(Object.assign({}, defaultConfigs)));
  const maxSlide = inject("maxSlide", ref(1));
  const minSlide = inject("minSlide", ref(1));
  const currentSlide = inject("currentSlide", ref(1));
  const nav = inject("nav", {});
  const isRTL = config.dir === "rtl";
  const prevButton = h("button", {
    type: "button",
    class: [
      "carousel__prev",
      !config.wrapAround && currentSlide.value <= minSlide.value && "carousel__prev--disabled",
      attrs === null || attrs === void 0 ? void 0 : attrs.class
    ],
    "aria-label": `Navigate to previous slide`,
    onClick: nav.prev
  }, (slotPrev === null || slotPrev === void 0 ? void 0 : slotPrev()) || h(Icon, { name: isRTL ? "arrowRight" : "arrowLeft" }));
  const nextButton = h("button", {
    type: "button",
    class: [
      "carousel__next",
      !config.wrapAround && currentSlide.value >= maxSlide.value && "carousel__next--disabled",
      attrs === null || attrs === void 0 ? void 0 : attrs.class
    ],
    "aria-label": `Navigate to next slide`,
    onClick: nav.next
  }, (slotNext === null || slotNext === void 0 ? void 0 : slotNext()) || h(Icon, { name: isRTL ? "arrowLeft" : "arrowRight" }));
  return [prevButton, nextButton];
};
var Pagination = () => {
  const maxSlide = inject("maxSlide", ref(1));
  const minSlide = inject("minSlide", ref(1));
  const currentSlide = inject("currentSlide", ref(1));
  const slidesCount = inject("slidesCount", ref(1));
  const nav = inject("nav", {});
  function handleButtonClick(slideNumber) {
    nav.slideTo(slideNumber);
  }
  const isActive = (slide) => {
    const val = mapNumberToRange(currentSlide.value, slidesCount.value - 1, 0);
    return val === slide;
  };
  const children = [];
  for (let slide = minSlide.value; slide < maxSlide.value + 1; slide++) {
    const button = h("button", {
      type: "button",
      class: {
        "carousel__pagination-button": true,
        "carousel__pagination-button--active": isActive(slide)
      },
      "aria-label": `Navigate to slide ${slide + 1}`,
      onClick: () => handleButtonClick(slide)
    });
    const item = h("li", { class: "carousel__pagination-item", key: slide }, button);
    children.push(item);
  }
  return h("ol", { class: "carousel__pagination" }, children);
};
var Slide = defineComponent({
  name: "CarouselSlide",
  props: {
    index: {
      type: Number,
      default: 1
    },
    isClone: {
      type: Boolean,
      default: false
    }
  },
  setup(props, { slots }) {
    const config = inject("config", reactive(Object.assign({}, defaultConfigs)));
    const currentSlide = inject("currentSlide", ref(0));
    const slidesToScroll = inject("slidesToScroll", ref(0));
    const slideWidth = inject("slideWidth", ref(0));
    const isSliding = inject("isSliding", ref(false));
    const slideStyle = computed(() => {
      return {
        width: slideWidth.value ? `${slideWidth.value}px` : `100%`
      };
    });
    const isActive = () => props.index === currentSlide.value;
    const isVisible = () => {
      const min = Math.floor(slidesToScroll.value);
      const max = Math.ceil(slidesToScroll.value + config.itemsToShow - 1);
      return props.index >= min && props.index <= max;
    };
    const isPrev = () => props.index === currentSlide.value - 1;
    const isNext = () => props.index === currentSlide.value + 1;
    return () => {
      var _a;
      return h("li", {
        style: slideStyle.value,
        class: {
          carousel__slide: true,
          "carousel_slide--clone": props.isClone,
          "carousel__slide--visible": isVisible(),
          "carousel__slide--active": isActive(),
          "carousel__slide--prev": isPrev(),
          "carousel__slide--next": isNext(),
          "carousel__slide--sliding": isSliding.value
        },
        "aria-hidden": !isVisible()
      }, (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots));
    };
  }
});
export {
  Carousel,
  Icon,
  Navigation,
  Pagination,
  Slide
};
/**
 * Vue 3 Carousel 0.2.0
 * (c) 2022
 * @license MIT
 */
//# sourceMappingURL=vue3-carousel.js.map
