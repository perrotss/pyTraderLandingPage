'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const emoji_convert = require('../convert.cjs');
const emoji_data = require('../data.cjs');
const emoji_format = require('../format.cjs');

function createEmojiRegExp(regexp) {
  return new RegExp(regexp, "g");
}
function getEmojiMatchesInText(regexp, content) {
  const results = [];
  const matches = content.match(
    typeof regexp === "string" ? createEmojiRegExp(regexp) : regexp
  );
  if (matches) {
    matches.sort((a, b) => {
      if (b.length === a.length) {
        return a.localeCompare(b);
      }
      return b.length - a.length;
    });
    let lastMatch;
    for (let i = 0; i < matches.length; i++) {
      const match = matches[i];
      if (lastMatch && lastMatch.match === match) {
        continue;
      }
      const sequence = [];
      for (const codePoint of match) {
        const num = codePoint.codePointAt(0);
        if (num !== emoji_data.vs16Emoji) {
          sequence.push(num);
        }
      }
      const keyword = emoji_format.getEmojiSequenceString(
        emoji_convert.convertEmojiSequenceToUTF32(sequence)
      );
      lastMatch = {
        match,
        sequence,
        keyword
      };
      results.push(lastMatch);
    }
  }
  return results;
}
function sortEmojiMatchesInText(content, matches) {
  const ranges = [];
  const check = (start, end) => {
    for (let i = 0; i < ranges.length; i++) {
      if (start < ranges[i].end && end >= ranges[i].start) {
        return false;
      }
    }
    return true;
  };
  for (let i = 0; i < matches.length; i++) {
    const match = matches[i];
    const search = match.match;
    let startFrom = 0;
    let start;
    while ((start = content.indexOf(search, startFrom)) !== -1) {
      const end = start + search.length;
      startFrom = end;
      if (check(start, end)) {
        ranges.push({
          start,
          end,
          match
        });
      }
    }
  }
  ranges.sort((a, b) => a.start - b.start);
  const list = [];
  let prevRange;
  let lastEnd;
  for (let i = 0; i < ranges.length; i++) {
    const range = ranges[i];
    const prev = content.slice(prevRange ? prevRange.end : 0, range.start);
    list.push({
      match: range.match,
      prev
    });
    prevRange = range;
    lastEnd = range.end;
  }
  if (!lastEnd) {
    return [];
  }
  const replacements = list.map((item, index) => {
    const nextItem = list[index + 1];
    return {
      ...item,
      next: nextItem ? nextItem.prev : content.slice(lastEnd)
    };
  });
  return replacements;
}

exports.createEmojiRegExp = createEmojiRegExp;
exports.getEmojiMatchesInText = getEmojiMatchesInText;
exports.sortEmojiMatchesInText = sortEmojiMatchesInText;
