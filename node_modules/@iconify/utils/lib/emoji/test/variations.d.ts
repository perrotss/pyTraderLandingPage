import { EmojiTestDataItem } from './parse.js';

/**
 * Get qualified sequence, adding optional `FE0F` wherever it might exist
 *
 * This might result in sequence that is not actually valid, but considering
 * that `FE0F` is always treated as optional, full sequence used in regex will
 * catch both qualified and unqualified emojis, so proper sequence will get
 * caught anyway. This function just makes sure that in case if sequence does
 * have `FE0F`, it will be caught by regex too.
 */
declare function guessQualifiedEmojiSequence(sequence: number[]): number[];
/**
 * Get qualified variations for emojis
 *
 * Also converts list to UTF-32 as needed and removes duplicate items
 *
 * `testData`, returned by parseEmojiTestFile() is used to check which emojis have `FE0F` variations.
 * If missing or emoji is missing in test data, `FE0F` is added to every single code emoji.
 * It can also be an array of sequences.
 */
declare function getQualifiedEmojiVariations(sequences: number[][], testData?: (number[] | EmojiTestDataItem)[]): number[][];
declare function getQualifiedEmojiVariations(sequences: number[][], testData: (number[] | EmojiTestDataItem)[], toString: (value: number[]) => string): string[];

export { getQualifiedEmojiVariations, guessQualifiedEmojiSequence };
