import { emojiComponents, vs16Emoji } from '../data.mjs';
import { getEmojiSequenceString } from '../format.mjs';
import { mapEmojiTestDataComponents } from './components.mjs';
import { mapEmojiTestDataBySequence } from './parse.mjs';
import '../convert.mjs';
import '../cleanup.mjs';

const nameSplit = ": ";
const variationSplit = ", ";
const ignoredVariations = /* @__PURE__ */ new Set(["person"]);
function splitEmojiNameVariations(name, sequence, componentsData) {
  const parts = name.split(nameSplit);
  const base = parts.shift();
  if (!parts.length) {
    return {
      base,
      key: base
    };
  }
  let startIndex = 0;
  let components = 0;
  const keyParts = [];
  const variations = parts.join(nameSplit).split(variationSplit).map((text) => {
    const type = componentsData.types[text];
    if (!type) {
      if (!ignoredVariations.has(text)) {
        keyParts.push(text);
      }
      return text;
    }
    const range = emojiComponents[type];
    while (startIndex < sequence.length) {
      const num = sequence[startIndex];
      startIndex++;
      if (num >= range[0] && num <= range[1]) {
        components++;
        return {
          index: startIndex - 1,
          type
        };
      }
    }
    throw new Error(
      `Cannot find variation in sequence for "${name}", [${sequence.join(
        " "
      )}]`
    );
  });
  const key = base + (keyParts.length ? nameSplit + keyParts.join(variationSplit) : "");
  return {
    base,
    key,
    variations,
    components
  };
}
function mergeComponentTypes(value) {
  return "[" + value.join(",") + "]";
}
function mergeComponentsCount(value) {
  const keys = [];
  for (const key in emojiComponents) {
    const type = key;
    for (let i = 0; i < value[type]; i++) {
      keys.push(type);
    }
  }
  return keys.length ? mergeComponentTypes(keys) : "";
}
function getEmojiComponentsMap(testData, componentsMap) {
  const components = componentsMap || mapEmojiTestDataComponents(
    mapEmojiTestDataBySequence(testData, getEmojiSequenceString),
    getEmojiSequenceString
  );
  const cleanSequence = (sequence) => {
    return getEmojiSequenceString(
      sequence.filter(
        (num) => num !== vs16Emoji && !components.converted.has(num)
      )
    );
  };
  const splitData = /* @__PURE__ */ Object.create(null);
  const defaultSplitDataKey = "default";
  testData.forEach((item) => {
    const split = splitEmojiNameVariations(
      item.name,
      item.sequence,
      components
    );
    const parent = splitData[split.key] || (splitData[split.key] = /* @__PURE__ */ Object.create(null));
    let sequenceKey = defaultSplitDataKey;
    const itemComponents = {
      "hair-style": 0,
      "skin-tone": 0
    };
    if (split.components) {
      split.variations?.forEach((item2) => {
        if (typeof item2 !== "string") {
          itemComponents[item2.type]++;
        }
      });
      sequenceKey = mergeComponentsCount(itemComponents) || defaultSplitDataKey;
    }
    const prevItem = parent[sequenceKey];
    if (!prevItem) {
      parent[sequenceKey] = {
        item,
        split,
        components: itemComponents
      };
      return;
    }
    if (cleanSequence(prevItem.item.sequence) !== cleanSequence(item.sequence)) {
      throw new Error(`Mismatched items with same key: ${sequenceKey}`);
    }
    if (item.sequence.length > prevItem.item.sequence.length) {
      parent[sequenceKey] = {
        item,
        split,
        components: itemComponents
      };
    }
  });
  const results = [];
  for (const key in splitData) {
    const items = splitData[key];
    const getItem = (components2) => {
      const key2 = mergeComponentsCount(components2) || defaultSplitDataKey;
      const item = items[key2];
      if (!item) {
        return;
      }
      const split = item.split;
      const variations = split.variations;
      const sequence = item.item.sequence.slice(
        0
      );
      variations?.forEach((chunk) => {
        if (typeof chunk === "string") {
          return;
        }
        sequence[chunk.index] = chunk.type;
      });
      const counter = {
        "hair-style": 0,
        "skin-tone": 0
      };
      const nameVariations = variations?.map((chunk) => {
        if (typeof chunk === "string") {
          return chunk;
        }
        const count = counter[chunk.type]++;
        if (components2[chunk.type] < count) {
          throw new Error("Bad variations order");
        }
        return `{${chunk.type}-${count}}`;
      });
      const name = split.base + (nameVariations?.length ? nameSplit + nameVariations.join(variationSplit) : "");
      return {
        name,
        sequence
      };
    };
    const checkChildren = (parent, components2) => {
      let found = false;
      for (const key2 in emojiComponents) {
        const type = key2;
        const childComponents = {
          ...components2
        };
        childComponents[type]++;
        const childItem = getItem(childComponents);
        if (childItem) {
          found = true;
          const children = parent.children || (parent.children = {});
          children[type] = childItem;
          checkChildren(childItem, childComponents);
        }
      }
      return found;
    };
    const mainItem = getItem({
      "hair-style": 0,
      "skin-tone": 0
    });
    if (mainItem) {
      if (checkChildren(mainItem, {
        "hair-style": 0,
        "skin-tone": 0
      })) {
        results.push(mainItem);
      }
    }
  }
  return results;
}

export { getEmojiComponentsMap, splitEmojiNameVariations };
