'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const emoji_cleanup = require('../cleanup.cjs');
const emoji_convert = require('../convert.cjs');
const emoji_data = require('../data.cjs');
const emoji_format = require('../format.cjs');
const emoji_test_parse = require('./parse.cjs');

function guessQualifiedEmojiSequence(sequence) {
  const split = emoji_cleanup.splitEmojiSequences(sequence).map((part) => {
    if (part.indexOf(emoji_data.vs16Emoji) !== -1) {
      return part;
    }
    if (part.length === 2 && part[1] === emoji_data.keycapEmoji) {
      return [part[0], emoji_data.vs16Emoji, part[1]];
    }
    return part.length === 1 ? [part[0], emoji_data.vs16Emoji] : part;
  });
  return emoji_cleanup.joinEmojiSequences(split);
}
function getQualifiedEmojiVariations(sequences, testData = [], toString) {
  const convert = toString || emoji_format.getEmojiSequenceString;
  const testSequences = testData.map(
    (item) => item instanceof Array ? item : item.sequence
  );
  const testDataMap = emoji_test_parse.getQualifiedEmojiSequencesMap(testSequences, convert);
  const set = /* @__PURE__ */ new Set();
  sequences.forEach((sequence) => {
    const convertedSequence = emoji_convert.convertEmojiSequenceToUTF32(sequence);
    const cleanSequence = emoji_cleanup.removeEmojiVariations(convertedSequence);
    const mapKey = convert(cleanSequence);
    if (testDataMap[mapKey]) {
      set.add(testDataMap[mapKey]);
      return;
    }
    set.add(convert(guessQualifiedEmojiSequence(cleanSequence)));
  });
  const results = Array.from(set);
  return toString ? results : results.map(emoji_cleanup.getEmojiSequenceFromString);
}

exports.getQualifiedEmojiVariations = getQualifiedEmojiVariations;
exports.guessQualifiedEmojiSequence = guessQualifiedEmojiSequence;
