import { splitEmojiSequences, joinEmojiSequences, removeEmojiVariations, getEmojiSequenceFromString } from '../cleanup.mjs';
import { convertEmojiSequenceToUTF32 } from '../convert.mjs';
import { vs16Emoji, keycapEmoji } from '../data.mjs';
import { getEmojiSequenceString } from '../format.mjs';
import { getQualifiedEmojiSequencesMap } from './parse.mjs';

function guessQualifiedEmojiSequence(sequence) {
  const split = splitEmojiSequences(sequence).map((part) => {
    if (part.indexOf(vs16Emoji) !== -1) {
      return part;
    }
    if (part.length === 2 && part[1] === keycapEmoji) {
      return [part[0], vs16Emoji, part[1]];
    }
    return part.length === 1 ? [part[0], vs16Emoji] : part;
  });
  return joinEmojiSequences(split);
}
function getQualifiedEmojiVariations(sequences, testData = [], toString) {
  const convert = toString || getEmojiSequenceString;
  const testSequences = testData.map(
    (item) => item instanceof Array ? item : item.sequence
  );
  const testDataMap = getQualifiedEmojiSequencesMap(testSequences, convert);
  const set = /* @__PURE__ */ new Set();
  sequences.forEach((sequence) => {
    const convertedSequence = convertEmojiSequenceToUTF32(sequence);
    const cleanSequence = removeEmojiVariations(convertedSequence);
    const mapKey = convert(cleanSequence);
    if (testDataMap[mapKey]) {
      set.add(testDataMap[mapKey]);
      return;
    }
    set.add(convert(guessQualifiedEmojiSequence(cleanSequence)));
  });
  const results = Array.from(set);
  return toString ? results : results.map(getEmojiSequenceFromString);
}

export { getQualifiedEmojiVariations, guessQualifiedEmojiSequence };
