import { getUnqualifiedEmojiSequence } from '../cleanup.mjs';
import { emojiComponents } from '../data.mjs';
import { getEmojiSequenceString } from '../format.mjs';
import { mapEmojiTestDataComponents } from './components.mjs';
import { getEmojiComponentsMap } from './name.mjs';
import { mapEmojiTestDataBySequence } from './parse.mjs';
import '../convert.mjs';

function addToComponentsIteration(components, attr, value) {
  const result = {
    "hair-style": components["hair-style"].slice(0),
    "skin-tone": components["skin-tone"].slice(0)
  };
  result[attr].push(value);
  return result;
}
function addComponentsToSequence(sequence, components) {
  const indexes = {
    "hair-style": 0,
    "skin-tone": 0
  };
  return sequence.map((value) => {
    if (typeof value === "number") {
      return value;
    }
    const index = indexes[value]++;
    return components[value][index];
  });
}
function getSequence(sequence) {
  const qualified = {
    type: "qualified",
    sequence,
    key: getEmojiSequenceString(sequence)
  };
  const unqualifiedSequence = getUnqualifiedEmojiSequence(sequence);
  const unqualified = unqualifiedSequence.length === sequence.length ? {
    ...qualified,
    type: "unqualified"
  } : {
    type: "unqualified",
    sequence: unqualifiedSequence,
    key: getEmojiSequenceString(unqualifiedSequence)
  };
  return {
    qualified,
    unqualified
  };
}
function getEmojisSequencesToCopy(sequences, testData) {
  const results = [];
  const componentsMap = mapEmojiTestDataComponents(
    mapEmojiTestDataBySequence(testData, getEmojiSequenceString),
    getEmojiSequenceString
  );
  const componentsMapItems = getEmojiComponentsMap(testData, componentsMap);
  const existingItems = /* @__PURE__ */ Object.create(null);
  const copiedItems = /* @__PURE__ */ Object.create(null);
  sequences.forEach((sequence) => {
    existingItems[getEmojiSequenceString(sequence)] = sequence;
  });
  const itemExists = (sequence) => {
    return existingItems[sequence.qualified.key] ? "qualified" : existingItems[sequence.unqualified.key] ? "unqualified" : void 0;
  };
  const itemWasCopied = (sequence) => {
    return copiedItems[sequence.qualified.key] ? "qualified" : copiedItems[sequence.unqualified.key] ? "unqualified" : void 0;
  };
  const addToCopy = (source, sourceName, target, targetName) => {
    copiedItems[target.key] = target.sequence;
    results.push({
      source: source.sequence,
      sourceName,
      target: target.sequence,
      targetName
    });
  };
  const getName = (item, components) => {
    let name = item.name;
    for (const key in emojiComponents) {
      const type = key;
      for (let i = 0; i < components[type].length; i++) {
        const num = components[type][i];
        const text = componentsMap.names.get(num);
        name = name.replace(`{${type}-${i}}`, text);
      }
    }
    return name;
  };
  const checkItem = (parentItem, parentSequence, parentComponents, onlyIfExists = true) => {
    const children = parentItem.children;
    if (!children) {
      return;
    }
    for (const key in emojiComponents) {
      const type = key;
      if (children[type]) {
        const childItem = children[type];
        const range = emojiComponents[type];
        for (let num = range[0]; num < range[1]; num++) {
          const components = addToComponentsIteration(
            parentComponents,
            type,
            num
          );
          const sequence = addComponentsToSequence(
            childItem.sequence,
            components
          );
          const sequences2 = getSequence(sequence);
          const existingSequence = itemExists(sequences2);
          if (existingSequence) {
            checkItem(
              childItem,
              sequences2[existingSequence],
              components,
              onlyIfExists
            );
            continue;
          }
          let copiedSequence = itemWasCopied(sequences2);
          if (copiedSequence && onlyIfExists) {
            continue;
          }
          if (!copiedSequence) {
            copiedSequence = parentSequence.type;
            addToCopy(
              parentSequence,
              getName(parentItem, parentComponents),
              sequences2[copiedSequence],
              getName(childItem, components)
            );
          }
          checkItem(
            childItem,
            sequences2[copiedSequence],
            components,
            onlyIfExists
          );
        }
      }
    }
  };
  componentsMapItems.forEach((mainItem) => {
    const sequence = getSequence(mainItem.sequence);
    const type = itemExists(sequence);
    if (!type) {
      return;
    }
    checkItem(
      mainItem,
      sequence[type],
      {
        "hair-style": [],
        "skin-tone": []
      },
      true
    );
    checkItem(
      mainItem,
      sequence[type],
      {
        "hair-style": [],
        "skin-tone": []
      },
      false
    );
  });
  return results;
}

export { getEmojisSequencesToCopy };
