import { getEmojiSequenceFromString, getUnqualifiedEmojiSequence } from '../cleanup.mjs';
import { getEmojiSequenceString } from '../format.mjs';
import '../convert.mjs';
import '../data.mjs';

const componentStatus = "component";
const allowedStatus = /* @__PURE__ */ new Set([
  componentStatus,
  "fully-qualified",
  "minimally-qualified",
  "unqualified"
]);
function parseEmojiTestFile(data) {
  const results = [];
  let group;
  let subgroup;
  data.split("\n").forEach((line) => {
    line = line.trim();
    const parts = line.split("#");
    if (parts.length < 2) {
      return;
    }
    const firstChunk = parts.shift().trim();
    const secondChunk = parts.join("#").trim();
    if (!firstChunk) {
      const commentParts = secondChunk.split(":");
      if (commentParts.length === 2) {
        const key = commentParts[0].trim();
        const value = commentParts[1].trim();
        switch (key) {
          case "group":
            group = value;
            subgroup = void 0;
            break;
          case "subgroup":
            subgroup = value;
            break;
        }
      }
      return;
    }
    if (!group || !subgroup) {
      return;
    }
    const firstChunkParts = firstChunk.split(";");
    if (firstChunkParts.length !== 2) {
      return;
    }
    const code = firstChunkParts[0].trim().replace(/\s+/g, "-").toLowerCase();
    if (!code || !code.match(/^[a-f0-9]+[a-f0-9-]*[a-f0-9]+$/)) {
      return;
    }
    const status = firstChunkParts[1].trim();
    if (!allowedStatus.has(status)) {
      throw new Error(`Bad emoji type: ${status}`);
    }
    const secondChunkParts = secondChunk.split(/\s+/);
    if (secondChunkParts.length < 3) {
      throw new Error(`Bad emoji comment for: ${code}`);
    }
    const emoji = secondChunkParts.shift();
    const version = secondChunkParts.shift();
    if (version.slice(0, 1) !== "E") {
      throw new Error(`Bad unicode version "${version}" for: ${code}`);
    }
    const name = secondChunkParts.join(" ");
    results.push({
      group,
      subgroup,
      code,
      sequence: getEmojiSequenceFromString(code),
      emoji,
      status,
      version,
      name
    });
  });
  return results;
}
function getQualifiedEmojiSequencesMap(sequences, toString) {
  const convert = toString || getEmojiSequenceString;
  const results = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < sequences.length; i++) {
    const value = convert(sequences[i]);
    const unqualified = convert(getUnqualifiedEmojiSequence(sequences[i]));
    if (!results[unqualified] || results[unqualified].length < value.length) {
      results[unqualified] = value;
    }
  }
  if (toString) {
    return results;
  }
  const map = /* @__PURE__ */ new Map();
  for (const key in results) {
    const value = results[key];
    map.set(
      getEmojiSequenceFromString(key),
      getEmojiSequenceFromString(value)
    );
  }
  return map;
}
function mapEmojiTestDataBySequence(testData, convert) {
  const testSequences = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < testData.length; i++) {
    const item = testData[i];
    const keyword = convert(item.sequence);
    if (testSequences[keyword]) {
      throw new Error(`Duplicate entries for "${keyword}"`);
    }
    testSequences[keyword] = item;
  }
  return testSequences;
}

export { componentStatus, getQualifiedEmojiSequencesMap, mapEmojiTestDataBySequence, parseEmojiTestFile };
